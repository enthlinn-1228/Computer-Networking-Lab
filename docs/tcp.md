# TCP 文档
### 特点
* 全双工
* 点对点
* 可靠数据传输
* 传输字节流

### TCP 报文段结构
TCP 报文由首部字段和数据字段两部分组成。
**首部字段**
1. 源端口号和目的端口号
用于多路复用/分解
2. 32 比特的序号字段和确认号字段
用于实现可靠数据传输服务
3. 16 比特的接收窗口字段
发送方维护一个称为接收窗口(rwnd)的变量用来提供流量控制，提示接收方还有多少可用的缓存空间。

接收窗口 = 接收方缓存 - （接收方已放入接收缓存中的数据流的最后一个字节编号 - 接收方应用程序已读取的最后一个字节编号）。
4. 4 比特的首部长度字段
由于选项字段的原因，TCP 首部长度是可变的（通常选项字段为空，所以典型长度是 20 字节）。
5. 可选与变长的选项字段
用于双方协商最大报文段长度（MSS）时使用，或在高速网络环境下用作窗口调节因子时使用。
6. 6 比特的标志字段
PSH URG 一般不使用
* ACK 用于指示确认字段中的值是有效的
* RST 重置报文段，告诉发送方“我没有那个报文段的套接字，不要再发送了”
* SYN 用于连接建立
* FIN 用于连接拆除
* PSH 被设置时，表示接收方应立即将数据交给上层
* URG 表示报文段存在被发送方上层置为“紧急”的数据

### 连接建立过程（三次握手）
1. 客户端发送一个不包含应用层数据的 TCP 报文段，首部的 SYN 置为 1，随机选择一个初始序号放在 TCP 报文段的序号字段中。
2. TCP 报文段到达服务器主机后，提取报文段，为该 TCP 连接分配缓存和变量，并向客户端发送允许连接的 TCP 报文段（不包含应用层数据）。
这个报文段的首部包含 3 个信息：SYN 置为 1；确认号字段置为客户端的序号 + 1；随机选择自己的初始序号。
3. 收到服务器的 TCP 响应报文段后，客户端也要为该 TCP 连接分配缓存和变量，并向服务器发送一个报文段。这个报文段将服务器端的序号 + 1 放置在确认号字段中，
用来对服务器允许连接的报文段进行响应，因为连接已经建立，所以 SYN 置为 0。
最后一个阶段，报文段可以携带客户到服务器的数据。并且以后的每一个报文段，SYN 都置为 0。

### 连接拆除过程
1. 客户端发送一个 FIN 置为 1 的报文段。
2. 服务器回送一个确认报文段。
3. 服务器发送 FIN 置为 1 的报文段。
4. 客户端回送一个确认报文段。

### 发送与接收过程
**发送**
TCP 发送方仅需维护已发送但未确认的字节的最小序号（SendBase）和下一个要发送的字节的序号（NextSeqNum）。
1. 客户进程通过套接字将数据传给 TCP，TCP 将数据放到该连接的发送缓存，接下来 TCP 会不时的从发送缓存里取出一块数据发送。
2. 发送时 TCP 会为数据加上 TCP 首部，从而形成报文段。
3. 报文段下发到网络层，网络层将其封装成 IP 数据报，最后经历链路层、物理层发送到网络中。

**接收**
TCP 接收方会将正确接收但失序的报文缓存起来。
1. 接收时从物理层、链路层、网络层一路解包，最后到达传输层。
2. TCP 接收后会放到该连接的接收缓存，
3. 应用程序通过套接字从此缓存读取数据流。

### 名词解释
1. MSS
最大报文段长度，指报文段应用层数据的最大长度，不包括 TCP 头部

2. MTU
最大链路层帧长度，以太网和 PPP 链路层协议具有 1500 字节的 MTU，因此 MSS 的典型值为 1460 字节（TPC/IP 首部长度通常为 40 字节）。

3. 路径 MTU
指从源到目的地的所有链路层上，所能发送的最大链路层帧

4. 累积确认
TCP 确认号是接收方期望从发送方收到的下一字节的序号。TCP 只确认从流开始到第一个丢失字节为止的字节，所以被称为累积确认。
假如发送方发送了 0-10，11-20，21-30 三个报文段，接收方由于某种原因只收到 0-10 和 21-30 字段，所以它下一个报文段的确认号为 11，表示期望收到字节 11（及以后）。

5. 重传
TCP 重传具有最小序号的还未被确认的报文段。

6. 重传超时间隔
它被设置为平均往返时间加上一点余量。重传发生后，下一次的超时间隔被设置为之前的两倍。

7. 快速重传
当接收方接收到一个比期望序号大的失序报文时，说明有报文段丢失，接收方将对最后一次按序字节数据进行重复确认（产生一个冗余 ACK）。
因为发送方是流水线式（一个接一个）发送报文，如果一个报文段丢失，很可能会引起多个冗余的 ACK。当发送方接收到对相同数据的 3 个冗余 ACK 时，
表明这个确认过 3 次的报文段已经丢失，发送方就执行快速重传，即在定时器过期之前重传丢失的字段。

8. 如何判断拥塞
TCP 发生丢包就是出现了拥塞。

丢包事件：超时或者收到接收方的 3 个冗余 ACK。

9. 拥塞窗口(cwnd)
发送方维护的一个额外变量，它对 TCP 发送流量速率进行了限制，在发送方中未被确认的数据量不会超过 cwnd 和 rwnd 中的最小值。
TCP 使用确认（成功收到接收方的 ACK）来触发增大它的拥塞窗口长度。

10. 拥塞控制算法
慢启动和拥塞避免是 TCP 的强制部分，两者的区别在于对收到的 ACK 做出反应时增加 cwnd 长度的方式。
慢启动比拥塞避免能更快地增加 cwnd 的长度。快速恢复是推荐部分，对于 TCP 发送方不是必需的。

（1）慢启动

慢启动 cwnd 初始值设为较小的值，每收到一个接收方的 ACK，就将 cwnd 的值翻倍（指数增长）。

结束慢启动有两种方式，一是当检查到拥塞时，这时将 ssthresh（慢启动阈值） 设为 cwnd/2，然后将 cwnd 置为 1 个 MSS，并重新开启慢启动。
二是到达或超过 ssthresh 值时，再翻倍就超过 cwnd 的值了，所以这时结束慢启动进入拥塞避免模式。


（2）拥塞避免
拥塞避免模式，每个 RTT 将 cwnd 的值增加一个 MSS。

结束拥塞避免有两种方式，第一种是超时，它和结束慢启动的方式一相同。第二种是收到 3 个冗余 ACK 时，将 ssthresh 置为 cwnd/2，
然后 cwnd = ssthresh + 3 * MSS， 接下来进入快速恢复模式。


（3）快速恢复

在快速恢复阶段，每收到重复的ACK，则cwnd加1；收到非重复ACK时，置cwnd = ssthresh，
转入拥塞避免阶段；如果发生超时重传，则置ssthresh为当前cwnd的一半，cwnd = 1，重新进入慢启动阶段。

快速恢复阶段退出条件：收到非重复ACK。
```
step1：
        if ( dupacks >= 3 ) {
                ssthresh = max( 2 , cwnd / 2 ) ;
                cwnd = ssthresh + 3 * SMSS ;
        }
 
step2：重传丢失的分组
 
step3：此后每收到一个重复的ACK确认时，cwnd++
 
step4：当收到对新发送数据的ACK确认时，cwnd = ssthresh，这个ACK能够对那些在
丢失的分组之后，第一个重复ACK之前发送的所有包进行确认。
```